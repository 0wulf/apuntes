{
	"nodes":[
		{"id":"92ab54ff66b8a6d6","type":"group","x":2160,"y":-6320,"width":4564,"height":5341,"label":"Un Agoritmo Distribuido"},
		{"type":"group","id":"f454a5bcbdbdfa40","x":2160,"y":9040,"width":5660,"height":2880,"label":"Detección de Terminación"},
		{"type":"group","id":"01f62df975f93558","x":2160,"y":3520,"width":2691,"height":5300,"label":"Remote Procedure Call"},
		{"id":"40ef3cd2ae28c86c","type":"group","x":2160,"y":-640,"width":2760,"height":3920,"label":"Arquitecturas"},
		{"id":"95893c24091ff868","type":"group","x":2080,"y":14180,"width":2560,"height":2220,"label":"El problema de los filósofos comensales"},
		{"id":"b9c20b4b43513345","type":"group","x":2160,"y":12160,"width":3360,"height":1640,"label":"Instantáneas Globales"},
		{"id":"d65cae2dc9ab5b32","x":2360,"y":20360,"width":561,"height":378,"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-08-Consenso.md"},
		{"id":"6ab50c983eb82305","type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-07-Relojes Vectoriales.md","x":2434,"y":19520,"width":603,"height":372},
		{"type":"text","text":"# Algoritmos basados en *tokens*\nEl permiso para entrar a la SC está asociado con la posesión del *token*:\n* La exclusión mutua se satisface trivialmente\n* Son relativamente eficientes: basta un mensaje para pasar el *token*,\n* y el nodo que tiene el token puede entrar a su SC un número arbitrario de veces sin tener que enviar o recibir mensajes.\nEn estos algoritmos, el desafío es asegurar que no hayan *deadlocks* ni inanición.\n\n\n","id":"75085d8a5010f59a","x":3260,"y":-2874,"width":810,"height":308},
		{"type":"text","text":"# Algoritmo de Ricart-Agrawala\nUsaremos dos procesos por nodo (comparten memoria y variables)\n* `main` proceso que quiere entrar a la sección crítica\n* `receive` el proceso que recibe y procesa solicitudes de otros nodos (en particular cuando `main` está ejecutando su protocolo de entrada)\n```\nint my# <- 0\nset deferred <- 0\n\nprocess main:\n\twhile (true):\n\t\t<sección no crítica>\n\t\t# protocolo de entrada\n\t\tfor (all other nodes i):\n\t\t\tsend rqst[i](myID, my#)\n\t\tawait replies from all other nodes\n\t\t<sección crítica>\n\t\t# protocolo de salida\n\t\tfor (all nodes in deferred):\n\t\t\tnodeID <- deferred.remove()\n\t\t\tsend rply[nodeID](myID)\n\nprocess receive:\n\tint nodeID, rqst#\n\twhile (true):\n\t\treceive rqst(node,ID, rqst#)\n\t\tif (rqst# < my#):\n\t\t\tsend rply[nodeID](myID)\n\t\telse:\n\t\t\tdeferred.insert(nodeID)\n```\nLa solución anterior tiene tres problemas:\n1. Los procesos podrían elegir números iguales \n2. Los procesos deben elegir números monótonamente crecientes\n3. Algunos procesos podrían no querer entrar a la SC aún estando en su turno y estancar al resto.\nCorrijamos el algoritmo:\n1. Desempatarlos con el número único de proceso: el operador `<<` primero compara los operandos, si son iguales entonces compara los números nodeID de los procesos\n2. Cada proceso actualiza una variable local `highest` asignándole el número `rqst#` más grande que ha visto hasta el momento.\n3. Variable que indique si quiere o no entrar a su SC\n\n```\nint my# <- 0, highest <- 0\nset deferred <- vacío\nbool rqstCS <- false\n\n// process main:\nwhile (true):\n\t<sección no crítica>\n\trqstCS <- true\n\tmy# <- highest + 1\n\tfor (all other nodes i):\n\t\tsend rqst[i](myID, my#)\n\tawait replies from all other nodes\n\t<sección crítica>\n\trqstCS <- false\n\tfor (all nodes in deferred):\n\t\tnodeID <- deferred.remove()\n\t\tsend rply[nodeID](myID)\n\n// process receive:\nint nodeID, rqst#\nwhile (true):\n\treceive rqst[myID](nodeID, rqst#)\n\thighest <- max(highest, rqst#)\n\tif (!rqstCS or (rqst# << my#)):\n\t\tsend rply[nodeID](myID)\n\telse:\n\t\tdeferred.insert(nodeID)\n```\n\nEste algoritmo puede ser ineficiente si hay muchos nodos:\nCada vez que un nodo quiere entrar a su SC debe enviar $n-1$ mensajes y recibir $n-1$ mensajes, incluso si nadie más quiere entrar: $O(n)$.\n","id":"4fe75e7ccd055ae2","x":5520,"y":-4990,"width":884,"height":2381},
		{"type":"text","text":"# Algoritmo de LeLann (token circulando en un anillo)\nLa solución es descentralizada y justa.\nComo los procesos `user[i]` tienen otro trabajo que hacer, empleamos procesos adicionales, `helper[i]` que son los que forman el anillo y se preocupan de enviar y recibir el token:\n- Circula un token -un mensaje nulo- entre los procesos `helper`\n- cuando `helper[i]` recibe el token, ve si `user[i]` quiere entrar a su SC, en cuyo caso se lo permite. de lo contrario solo hace circular el token.\n```\nchannel[1..n] token(),\n\tenter(),g(),exit()\n\nprocess helper[i=1..n]:\n\twhile true:\n\t\treceive token[i]()\n\t\tif (!empty(enter[i])):\n\t\t\treceive enter[i]()\n\t\t\tsend go[i]()\n\t\t\treceive exit[i]()\n\t\tsend token[i+1]()\n\nprocess user[i=1..n]:\n\twhile true:\n\t\tsend enter[i]()\n\t\treceive go[i]()\n\t\tSC\n\t\tsend exit[i]()\n```","id":"65c4b5d87c31ef1e","x":4440,"y":-3720,"width":798,"height":900},
		{"type":"text","text":"# El problema de la sección crítica\nQueremos asegurarnos que el acceso a la sección crítica se haga bajo exclusión mutua.\n```\nprocess p[i]:\n\twhile (true):\n\t\t<protocolo de entrada>\n\t\t<sección crítica>\n\t\t<protocolo de salida>\n\t\t<sección no critica>\n```\nEn SSOO+Redes nos interesaba este problema bajo memoria compartida.\n\nEl desafío es diseñar protocolos de entrada y salida de modo que se cumpla\nPropiedades de seguridad (1-3) y de progreso (4)\n1. Exclusión mutua: a lo más un proceso a la vez está ejecutando su sección crítica\n2. No hay deadlocks: si dos o más procesos están tratando de entrar a sus SCs, entonces a lo menos uno tendrá éxito.\n3. No hay postergación innecesaria\n4. Entrada: un proceso que está tratando de entrar a su SC eventualmente tendrá éxito.\n","id":"36a5e3f9c3e3b414","x":3260,"y":-4340,"width":880,"height":660},
		{"type":"text","text":"# Algoritmo de la panadería (bajo memoria compartida)\nUn proceso le pide permiso a todos los otros para entrar a la sección crítica.\n* Un proceso que quiere entrar a su SC primero mira los turnos de todos los otros procesos y luego define su propio turno como uno más que el de cualquier otro proceso.\n* El proceso luego espera comparando su turno con el de todos los otros procesos hasta que el suyo sea el menor de todos (exceptuando los 0s)\n```\nint[n]<-{0...0}\n\n// process p[i]\nwhile (true):\n\tturn[i] <- 1\n\tturn[i] <- max{turn[1],...,turn[n]}+1\n\tfor (j<-1..n, st j != i):\n\t\twhile ((turn[j] != 0) and ( (turn[i],i) > (turn[j],j) ));\n\t<sección crítica>\n\tturn[i] <- 0\n\t<sección no crítica>\n```","id":"ab522542d4f121d5","x":4440,"y":-4640,"width":980,"height":660},
		{"type":"text","text":"# Declaración de un canal\nUn canal es una cola de mensajes enviados pero aun no recibidos.\n`channel <ch>(<tp1> <id1>, ..., <tpn> <idn>)`\n* `<ch>` es el nombre del canal\n* `<tpi> <idi>` son los datos obligatorios y los nombres opcionales de los campos del mensaje transmitido\n#### Ejemplos\n```\nchannel input(char)\nchannel diskAccess(int cylinder, int block, int count,  char* buffer)\nchannel[n] result(int)    // Arreglo de canales \n```\n\n#### `send <ch>(<expr_1>, ..., <expr_n>)`\n* `<expr_i>` son expresiones cuyos tipos deben corresponder con los tipos de los campos en la declaración de `<ch>`\nEl efecto de ejecutar `send`:\n* Evaluar las expresiones\n* Agregar un mensaje con estos valores al final de la cola asociada con el canal `<ch>`\n\n`send` para el emisor: \n* no produce demora y\n* es NO bloqueante\n\n#### `receive <ch>(<var_1>, ..., <var_n>)`\n* `<var_i>` son variables cuyos tipos deben corresponder con los tipos de los campos en la declaración de `<ch>`\nEl efecto de ejecutar `receive`:\n* El proceso se suspende hasta que haya al menos un mensaje en la cola del canal de `<ch>`\n* entonces el proceso saca el mensaje que está al comienzo de la cola y asigna sus campos a los `<var_i>`\nEs una operación bloqueante: el proceso no necesita utilizar busy waiting.\n\n### Supongamos que los canales se comportan bien:\n* El acceso a un canal es atómico.\n* La entrega de un mensaje es confiable y libre de errores\n* Todo mensaje que es enviado a un canal es entregado y sin ser corrompido\n* Los canales son colas FIFO.","id":"3afea16f45cc11fc","x":3260,"y":-5720,"width":957,"height":1360},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-01-Un Algoritmo Distribuido.md","id":"004dc9a8c1b6e57a","x":2180,"y":-4885,"width":600,"height":545},
		{"type":"text","text":"# Algoritmo de sacar número (bajo memoria compartida)\nDos pasos fundamentales:\n* Un proceso que quiere entrar a su SC primero saca un número uno más grande que el número que tenga cualquier otro proceso\n* luego espera hasta que todos los procesos con números menores hayan pasado por su SC\n```\nint number <- 1\nnext <- 1\nint[n] turn <- {0...0}\n\n// process p[i]:\nwhile (true):\n\tturn[i] <- FA(number,1)   // FA es una operación atómica\n\twhile (turn[i] != next);\n\t<sección crítica>\n\tnext++\n\t<sección no crítica>\n```\n","id":"f28363d19630933d","x":4440,"y":-5320,"width":980,"height":659},
		{"type":"text","text":"# ¿Cómo escribimos programas para arquitecturas de memoria distribuida?\n* `read/write` requiere utilizar busy waiting explícitamente. Podemos hacerlo mejor\nDefiniremos **operaciones de red** que incluyan sincronización:\n* Operaciones básicas de paso de mensajes\n* si comparamos con memoria compartida extienden el concepto de los semáforos para transmitir datos además de emplear sincronización.\nLos procesos comparten **canales**:\n* Rutas de comunicación entre procesos.\n* Abstracción de la red de comunicaciones\nLos canales son los únicos objetos compartidos por los procesos:\n* Cada variable es local a un proceso\n* Las variables no están sujetas a accesos concurrentes - no se requieren mecanismos de exclusión mutua en el acceso a las variables\n* Los procesos deben comunicarse para interactuar","id":"3abd89a87bd888a6","x":3260,"y":-6300,"width":920,"height":560},
		{"type":"text","text":"# Arquitecturas basadas en objetos\n![[Pasted image 20230822172641.png]]\n","id":"64792d9e8ab79016","x":4000,"y":888,"width":665,"height":412},
		{"type":"text","text":"# Separación entre procesamiento y coordinación\n![[Pasted image 20230822172744.png]]\n","id":"004013204ecac01c","x":4000,"y":1380,"width":790,"height":485},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-00-Clase introductoria Sistemas distribuidos.md","id":"895c03e78446a207","x":-480,"y":-560,"width":420,"height":400},
		{"type":"text","text":"# ¿Qué define a una arquitectura de software?\n- Componentes: unidad modular con interfaces (requerida y provista) bien definidas que es reemplazable (mientras el sistema sigue operando) dentro de su entorno\n- La forma en que los componentes están conectados unos a otros: los conectores son mecanismos que median la comunicación, coordinación y cooperación entre componentes. e.g. RPC, paso de mensajes.\n- Los datos intercambiados entre componentes.\n- Cómo estos elementos son configurados conjuntamente en un sistema.","id":"2dfe3671b6d10847","x":3140,"y":1094,"width":569,"height":529},
		{"type":"text","text":"# Sistemas Distribuidos","id":"406c1ba5306c2497","x":-460,"y":-760,"width":360,"height":60,"color":"4"},
		{"type":"text","text":"# Algoritmo de Ricart-Agrawala, versión tokens\nUsamos dos arreglos en cada nodo para decidir si hay solicitudes pendientes:\n- `granted`, número `my#` de cada nodo (proceso) la última vez que se le concedió permiso para entrar a su SC\n\t- va incluido en el mismo mensaje que se usa para enviar el token\n\t- solo la copia que está en el nodo que tiene el token es significativa\n- `request`, números `my#` que acompañan a los últimos mensajes `rqst` de cada uno de los otros nodos\nEl token no se pasa a menos que se necesite:\nSi el nodo `i` que tiene el token que que\n```\nrequest[j] > granted[j] and request[k]>granted[k]\n```\npara los nodos `j` y `k` entonces:\n- si `i` no está en su SC, entonces envía el token a uno de `j` o `k` \n- si `i` está en su SC, entonces envía el token al salir de la SC\n- al enviar el token,  `i` también envía su arreglo `granted`\n```\nint[] request <- [0..0]\nint[] granted <- [0..0]\nint my# <- 0\nbool inCS <- false\nbool haveToken <- true en nodo 0, false en otros\n\nprocess main:\n\twhile true:\n\tNCS\n\tif !haveToken:\n\t\tmy# <- my# + 1\n\t\tfor all other nodes i:\n\t\t\tsend rqst[i](myID, my#)\n\t\treceive token(granted)\n\t\thaveToken <- true\n\tinCS <- true\n\tSC\n\tgranted[myID] <- my#\n\tinCS <- false\n\tsendToken\n\nprocess receiver:\n\tint source, req#\n\twhile true:\n\t\treceive rqst[myID](source, req#)\n\t\trequest[source] <- max(request[source], req#)\n\t\tif (haveToken and !inCS):\n\t\t\tsendToken\n\nsendToken:\n\tif (exists p such that request[p] > granted[p]):\n\t\tfor (some such p):\n\t\t\tsend token(p, granted)\n\t\t\thaveToken <- false\n```\n","id":"7ea8c9fb97e43a6c","x":4440,"y":-2740,"width":798,"height":1661},
		{"type":"text","text":"# Arquitecturas estratificadas o por capas\n![[Pasted image 20230822171751.png]]\n### e.g. Stacks de protocolos de comunicación\n- Cada capa implementa uno o varios servicios de comunicación, ofrecidos por la capa para enviar datos de un interlocutor a otro (u otros)\n- Cada capa ofrece una interfaz a través de la cual el servicio se vuelve disponible, que especifica las funciones que pueden ser llamadas y que oculta la implementación del servicio.\n- Cada capa implementa un protocolo, que describe las reglas que los interlocutores deben seguir para establecer la comunicación e intercambiar información.\n### e.g Estratificación lógica de las aplicaciones\nLos diferencia en tres niveles lógicos que siguen un estilo arquitectónico estratificado para permitir acceso a bases de datos:\n- El nivel de la interfaz de aplicación, que maneja la interacción con el usuario o con una aplicación externa\n- El nivel de procesamiento que contiene la funcionalidad central de la aplicación y que varía mucho de una aplicación a otra\n- El nivel de datos, que opera sobre una pase de datos o sistema de archivos persistente.\n![[Pasted image 20230822172358.png]]\n","id":"20c0e0f2e3356fa4","x":4002,"y":-570,"width":749,"height":1380},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Estructura de comunicación general.md","subpath":"#El algoritmo para un grafo completo- Cada proceso está pintado de rojo o azul, con todos los procesos inicialmente rojos.","id":"586b19fd3788a43b","x":5420,"y":9810,"width":720,"height":1090},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/El grafo de nodos es un árbol.md","subpath":"#Algoritmo para detectar terminación basado en un árbol de cobertura","id":"403240f49e00bf19","x":3000,"y":10400,"width":660,"height":500},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/El grafo de nodos es un árbol.md","subpath":"#Una versión simple... pero no segura","id":"b418e4f40fd53dc8","x":3740,"y":10400,"width":700,"height":500},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/El grafo de nodos es un árbol.md","subpath":"#Una versión segura basada en colorear tokens y procesos","id":"11e63f7c96b39250","x":4520,"y":10400,"width":720,"height":500},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/04 Detección de Terminación.md","id":"d005a45b5a8fc618","x":2180,"y":9710,"width":640,"height":680},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Estructura de comunicación general.md","id":"bfad3f36ba832cbf","x":3020,"y":9790,"width":680,"height":520},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Estructura de comunicación general.md","subpath":"#Detectar terminación en general es más difícil los mensajes pueden llegar por cualquier arista","id":"c1a78c052f35bae3","x":4540,"y":9810,"width":680,"height":480},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Estructura de comunicación general.md","subpath":"#El algoritmo para un anillo no funciona en general (e.g. un grafo completo de 3 procesos)","id":"1f9ce5b96281916a","x":3780,"y":9830,"width":680,"height":440},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Circulación de un token.md","subpath":"#Condición de terminación Todo proceso está desocupado y no hay mensajes en tránsito","id":"ccefad9c5316e29f","x":3820,"y":9225,"width":740,"height":440},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Circulación de un token.md","subpath":"#Supongamos que circula un token en mensajes que no son parte de la computación misma","id":"d0fd362cd71bb3c3","x":4660,"y":9185,"width":760,"height":520},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Circulación de un token.md","id":"f1505081a6f0e67b","x":3000,"y":9235,"width":740,"height":420},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/Paso de parámetros en RPC.md","id":"1c0d56ce294ee2f5","x":3241,"y":8500,"width":739,"height":300},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/Operación transparente de RPC.md","id":"6e7e9d3eef9ad514","x":3241,"y":6560,"width":659,"height":1900},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/Un sistema de archivos distribuido.md","id":"a530f10a81bad146","x":4100,"y":6260,"width":731,"height":1812},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/Un módulo servidor de tiempo.md","id":"7b576185eabf2829","x":4100,"y":5020,"width":580,"height":1200},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/Desafíos de la implementación de RPC.md","id":"b9c479a69138cd63","x":3241,"y":6180,"width":640,"height":311},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/Propósito de RPC.md","id":"30dff4309816bae9","x":3240,"y":5740,"width":539,"height":400},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/Implementación de una llamada remota intermódulos.md","id":"efa1096dd2aef9fe","x":3240,"y":5020,"width":580,"height":680},
		{"type":"text","text":"# RPC (Remote Procedure Call)\n# [[ Los mensajes asíncronos no son siempre la mejor opción]]\n# [[RPC es mejor para programar interacciones cliente-servidor]]\n# [[Modelo RPC]]\n# [[Implementación de una llamada remota intermódulos]]\n# [[Propósito de RPC]]\n# [[Desafíos de la implementación de RPC]]\n# [[Operación transparente de RPC]]\n# [[Paso de parámetros en RPC]]","id":"db78a3f8ac4cb051","x":2200,"y":5050,"width":840,"height":620},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/Modelo RPC.md","id":"a98945d3ac1b7e59","x":3240,"y":4480,"width":762,"height":500},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/Forma de un módulo.md","id":"92c1049d38061837","x":4100,"y":4477,"width":536,"height":503},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/RPC es mejor para programar interacciones cliente-servidor.md","id":"77b18ef37eedd357","x":3240,"y":3960,"width":620,"height":480},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-03-RPC/Los mensajes asíncronos no son siempre la mejor opción.md","id":"29e6aac8eeb61a9b","x":3240,"y":3540,"width":900,"height":400},
		{"type":"text","text":"# Arquitecturas descentralizadas peer-to-peer\nDesde una perspectiva de alto nivel, los procesos que forman un sistema p2p son todos iguales:\n- Las funciones que deben ser llevadas a cabo están representadas por cada proceso\n- La mayor parte de la interacción esntre procesos es simétrica\n- Cada proceso actúa como cliente y como servidor al mismo tiempo\nUna red superpuesta (overlay network):\n- Los nodos son los procesos\n- Las conexiones representan los posibles canales de comunicación\n¿Cómo organizamos los procesos en una overlay network?\n- Es posible que un nodo no se comunique directamente con otro nodo arbitrario, si no que debe enviar mensajes a través de los canales disponibles\nDos tipos de overlay networks:\n- Estructurada\n- No estructurada\nSistema P2P estructurado:\n- Los nodos (procesos) están organizados de manera que adhieren a una topología determinista específica: anillo, árbol binario, grid, ...\n- La topología se usa para buscar información eficientemente\nSe basan en usar índices libres de semántica\n- Cada dato mantenido por el sistema está asociado de manera única a una clave utilizada como índice\ne.g. Funciones de Hash\n- El sistema almacena pares key, value\n\t- implementa una tabla de hash distribuida\n- la esencia del sistema consiste en poder buscar un dato a partir de su clave\n\t- el sistema debe ofrecer una implementación eficiente de una función que asocie una clave a un nodo\n\t- existing_node = lookup(key)\n- en este proceso de lookup cuando la topología de la red juega un rol crucial\n\t- hay que enrutar eficientemente las solicitudes de la búsqueda, desde el nodo que la solicita hasta el nodo que almacena el dato con la clave dada\n![[Pasted image 20230822174639.png]]\n![[Pasted image 20230822174646.png]]\n![[Pasted image 20230822174653.png]]\n![[Pasted image 20230822174704.png]]\n![[Pasted image 20230822174715.png]]\n","id":"da4ff2ce7cb0cc37","x":3140,"y":2420,"width":800,"height":640},
		{"type":"text","text":"# Arquitecturas publicación-subscripción\n![[Pasted image 20230822172904.png]]\n![[Pasted image 20230822172926.png]]\n![[Pasted image 20230822173049.png]]\n![[Pasted image 20230822173058.png]]\n![[Pasted image 20230822173117.png]]\n![[Pasted image 20230822173128.png]]\n![[Pasted image 20230822173142.png]]\n![[Pasted image 20230822173236.png]]\n![[Pasted image 20230822173245.png]]\n![[Pasted image 20230822173253.png]]\n![[Pasted image 20230822173300.png]]\n![[Pasted image 20230822173312.png]]\n![[Pasted image 20230822173450.png]]\n","id":"fd9264a31faa1de7","x":4000,"y":1940,"width":836,"height":480},
		{"id":"7bb7dd05388f9348","type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-02-Arquitecturas.md","x":2180,"y":1300,"width":680,"height":820},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Circulación de un token.md","subpath":"#Suponemos que, inicialmente `T[1]` tiene el token","id":"08f75917283841a8","x":6380,"y":9345,"width":740,"height":200},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Circulación de un token.md","subpath":"#¿Cómo detectamos cuando toda la computación ha terminado?","id":"97f132274bf386e3","x":5520,"y":9235,"width":740,"height":420},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Circulación de un token.md","subpath":"#El algoritmo para un anillo","id":"346e0b373758815a","x":7220,"y":9060,"width":580,"height":770},
		{"id":"499f876c18a34291","type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Algoritmo de Dijkstra-Scholten.md","subpath":"#2","x":3700,"y":11235,"width":590,"height":360},
		{"id":"d61e4881f18aeddc","type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Algoritmo de Dijkstra-Scholten.md","x":3020,"y":11007,"width":590,"height":817},
		{"id":"ba4152651c4140e4","type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Algoritmo de Dijkstra-Scholten.md","subpath":"#Versión preliminar","x":4360,"y":11190,"width":590,"height":451},
		{"id":"4336dd6efef0f9ca","type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Algoritmo de Dijkstra-Scholten.md","subpath":"#Cambios en el código de cada nodo","x":5040,"y":10993,"width":590,"height":845},
		{"id":"5c6c2e7979018ee4","type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-04-Detección de terminación/Algoritmo de Dijkstra-Scholten.md","subpath":"#¿Qué hace en nodo de entorno?","x":5740,"y":11123,"width":480,"height":585},
		{"id":"132e2c93290d2e28","type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-06-Relojes Lógicos.md","x":2360,"y":18280,"width":750,"height":985},
		{"id":"419f1bcdd57d7ef3","type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-09-Coordinación.md","x":2360,"y":21280,"width":820,"height":280},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-05-Instantáneas globales.md","subpath":"#Características generales del algoritmo","id":"1e65b17aafa9051c","x":4720,"y":12180,"width":780,"height":1600},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-05-Instantáneas globales.md","id":"cebaee5da3ac83d9","subpath":"#Consideraremos dos nodos y los mensajes enviados por el nodo 1 al nodo 2","x":3860,"y":12350,"width":780,"height":1260},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-05-Instantáneas globales.md","id":"c2b1cbd8f8852040","x":2180,"y":12750,"width":780,"height":460},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-05-Instantáneas globales.md","id":"ae68044bd7b3ca8d","subpath":"#El estado de los nodos y los canales","x":3020,"y":12810,"width":780,"height":340},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-05-El problema de los filósofos comensales.md","subpath":"#En memoria compartida el problema puede resolverse usando semáforos","id":"7d65e30ed640d307","x":3060,"y":14200,"width":740,"height":1020},
		{"type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-05-El problema de los filósofos comensales.md","id":"e2833a996e577ac0","subpath":"#Solución descentralizada (e higiénica)","x":3880,"y":14200,"width":740,"height":2180},
		{"id":"8df6bc27ffd1416c","type":"file","file":"200 Uni/210-Cursos actuales/213-sistemas-distribuidos-iic2523/213-05-El problema de los filósofos comensales.md","x":2100,"y":15050,"width":740,"height":480}
	],
	"edges":[
		{"id":"201dec58b01dc079","fromNode":"895c03e78446a207","fromSide":"right","toNode":"004dc9a8c1b6e57a","toSide":"left"},
		{"id":"8f2c05f7be9d1179","fromNode":"406c1ba5306c2497","fromSide":"bottom","toNode":"895c03e78446a207","toSide":"top"},
		{"id":"2ae14ada710a3c7e","fromNode":"895c03e78446a207","fromSide":"right","toNode":"7bb7dd05388f9348","toSide":"left"},
		{"id":"d2f3dfd393f69367","fromNode":"004dc9a8c1b6e57a","fromSide":"right","toNode":"3abd89a87bd888a6","toSide":"left"},
		{"id":"f5ea524a33275c02","fromNode":"004dc9a8c1b6e57a","fromSide":"right","toNode":"3afea16f45cc11fc","toSide":"left"},
		{"id":"b87bef3bd61f0024","fromNode":"004dc9a8c1b6e57a","fromSide":"right","toNode":"36a5e3f9c3e3b414","toSide":"left"},
		{"id":"bfaa8eb31905a950","fromNode":"36a5e3f9c3e3b414","fromSide":"right","toNode":"f28363d19630933d","toSide":"left"},
		{"id":"65df1d05261be297","fromNode":"36a5e3f9c3e3b414","fromSide":"right","toNode":"ab522542d4f121d5","toSide":"left"},
		{"id":"954db56371e76f7c","fromNode":"36a5e3f9c3e3b414","fromSide":"right","toNode":"4fe75e7ccd055ae2","toSide":"left"},
		{"id":"c6e5acfb516c3a81","fromNode":"895c03e78446a207","fromSide":"right","toNode":"db78a3f8ac4cb051","toSide":"left"},
		{"id":"501ec9a60c19c4e2","fromNode":"004dc9a8c1b6e57a","fromSide":"right","toNode":"75085d8a5010f59a","toSide":"left"},
		{"id":"0c8f2dca06b13360","fromNode":"75085d8a5010f59a","fromSide":"right","toNode":"65c4b5d87c31ef1e","toSide":"left"},
		{"id":"4e5f663a7f60868e","fromNode":"75085d8a5010f59a","fromSide":"right","toNode":"7ea8c9fb97e43a6c","toSide":"left"},
		{"id":"cd8167da2a27b9cf","fromNode":"7bb7dd05388f9348","fromSide":"right","toNode":"2dfe3671b6d10847","toSide":"left"},
		{"id":"71f0e11c54868f52","fromNode":"2dfe3671b6d10847","fromSide":"right","toNode":"20c0e0f2e3356fa4","toSide":"left"},
		{"id":"cc00a61ec2bc4813","fromNode":"2dfe3671b6d10847","fromSide":"right","toNode":"64792d9e8ab79016","toSide":"left"},
		{"id":"dda917c6be2927f8","fromNode":"2dfe3671b6d10847","fromSide":"right","toNode":"004013204ecac01c","toSide":"left"},
		{"id":"a972a302d05b5bef","fromNode":"2dfe3671b6d10847","fromSide":"right","toNode":"fd9264a31faa1de7","toSide":"left"},
		{"id":"76e82e618034e1ae","fromNode":"7bb7dd05388f9348","fromSide":"right","toNode":"da4ff2ce7cb0cc37","toSide":"left"},
		{"id":"ae950fdd1ee72a03","fromNode":"db78a3f8ac4cb051","fromSide":"right","toNode":"29e6aac8eeb61a9b","toSide":"left"},
		{"id":"9a472692b4f596d8","fromNode":"db78a3f8ac4cb051","fromSide":"right","toNode":"77b18ef37eedd357","toSide":"left"},
		{"id":"adc9ae8724d7371d","fromNode":"db78a3f8ac4cb051","fromSide":"right","toNode":"a98945d3ac1b7e59","toSide":"left"},
		{"id":"4b2c09feb9d1aa9d","fromNode":"a98945d3ac1b7e59","fromSide":"right","toNode":"92c1049d38061837","toSide":"left"},
		{"id":"049a5414441676cd","fromNode":"db78a3f8ac4cb051","fromSide":"right","toNode":"efa1096dd2aef9fe","toSide":"left"},
		{"id":"5a83136c389cfa4b","fromNode":"efa1096dd2aef9fe","fromSide":"right","toNode":"7b576185eabf2829","toSide":"left"},
		{"id":"128adc70dbbfc2e9","fromNode":"efa1096dd2aef9fe","fromSide":"right","toNode":"a530f10a81bad146","toSide":"left"},
		{"id":"75d827200baf69d4","fromNode":"db78a3f8ac4cb051","fromSide":"right","toNode":"30dff4309816bae9","toSide":"left"},
		{"id":"0e992f23ee5c1535","fromNode":"db78a3f8ac4cb051","fromSide":"right","toNode":"b9c479a69138cd63","toSide":"left"},
		{"id":"5f7535bd4f59253f","fromNode":"db78a3f8ac4cb051","fromSide":"right","toNode":"6e7e9d3eef9ad514","toSide":"left"},
		{"id":"a9187db2db4ea17f","fromNode":"db78a3f8ac4cb051","fromSide":"right","toNode":"1c0d56ce294ee2f5","toSide":"left"},
		{"id":"0422fc553eb6c4e6","fromNode":"895c03e78446a207","fromSide":"right","toNode":"d005a45b5a8fc618","toSide":"left"},
		{"id":"17345db366a38f4a","fromNode":"d005a45b5a8fc618","fromSide":"right","toNode":"f1505081a6f0e67b","toSide":"left"},
		{"id":"721d13dd17763c31","fromNode":"d005a45b5a8fc618","fromSide":"right","toNode":"403240f49e00bf19","toSide":"left"},
		{"id":"76839b5e9d05809f","fromNode":"f1505081a6f0e67b","fromSide":"right","toNode":"ccefad9c5316e29f","toSide":"left"},
		{"id":"291cc4a7dad56b7a","fromNode":"ccefad9c5316e29f","fromSide":"right","toNode":"d0fd362cd71bb3c3","toSide":"left"},
		{"id":"c3eadaaee81046a5","fromNode":"d0fd362cd71bb3c3","fromSide":"right","toNode":"97f132274bf386e3","toSide":"left"},
		{"id":"d5bf4a6b81d1c2e8","fromNode":"97f132274bf386e3","fromSide":"right","toNode":"08f75917283841a8","toSide":"left"},
		{"id":"851e567e6da98762","fromNode":"08f75917283841a8","fromSide":"right","toNode":"346e0b373758815a","toSide":"left"},
		{"id":"13aaca76a8410319","fromNode":"bfad3f36ba832cbf","fromSide":"right","toNode":"1f9ce5b96281916a","toSide":"left"},
		{"id":"f2fe5ff09b912571","fromNode":"1f9ce5b96281916a","fromSide":"right","toNode":"c1a78c052f35bae3","toSide":"left"},
		{"id":"c1c8cbda2c1bf2d6","fromNode":"d005a45b5a8fc618","fromSide":"right","toNode":"bfad3f36ba832cbf","toSide":"left"},
		{"id":"adb4e8301a8e15a8","fromNode":"c1a78c052f35bae3","fromSide":"right","toNode":"586b19fd3788a43b","toSide":"left"},
		{"id":"5b69a933cf677696","fromNode":"403240f49e00bf19","fromSide":"right","toNode":"b418e4f40fd53dc8","toSide":"left"},
		{"id":"e3f241386f31bb37","fromNode":"b418e4f40fd53dc8","fromSide":"right","toNode":"11e63f7c96b39250","toSide":"left"},
		{"id":"b9bfc5716bf72964","fromNode":"c2b1cbd8f8852040","fromSide":"right","toNode":"ae68044bd7b3ca8d","toSide":"left"},
		{"id":"5e0b9bd8c4df0f93","fromNode":"ae68044bd7b3ca8d","fromSide":"right","toNode":"cebaee5da3ac83d9","toSide":"left"},
		{"id":"a9b55410ae171bf4","fromNode":"cebaee5da3ac83d9","fromSide":"right","toNode":"1e65b17aafa9051c","toSide":"left"},
		{"id":"fe57556fcf498464","fromNode":"8df6bc27ffd1416c","fromSide":"right","toNode":"7d65e30ed640d307","toSide":"left"},
		{"id":"4774227c8bef447e","fromNode":"8df6bc27ffd1416c","fromSide":"right","toNode":"e2833a996e577ac0","toSide":"left"},
		{"id":"f5c7af358b13ba9d","fromNode":"895c03e78446a207","fromSide":"right","toNode":"c2b1cbd8f8852040","toSide":"left"},
		{"id":"e3203129c72da8ef","fromNode":"895c03e78446a207","fromSide":"right","toNode":"8df6bc27ffd1416c","toSide":"left"},
		{"id":"6c4ed287cca21644","fromNode":"d005a45b5a8fc618","fromSide":"right","toNode":"d61e4881f18aeddc","toSide":"left"},
		{"id":"c1c270f896b33970","fromNode":"d61e4881f18aeddc","fromSide":"right","toNode":"499f876c18a34291","toSide":"left"},
		{"id":"dcf9a5daa695fc15","fromNode":"499f876c18a34291","fromSide":"right","toNode":"ba4152651c4140e4","toSide":"left"},
		{"id":"95b40e7f142e8183","fromNode":"ba4152651c4140e4","fromSide":"right","toNode":"4336dd6efef0f9ca","toSide":"left"},
		{"id":"298845413ab541b5","fromNode":"4336dd6efef0f9ca","fromSide":"right","toNode":"5c6c2e7979018ee4","toSide":"left"}
	]
}